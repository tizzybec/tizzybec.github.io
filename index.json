[{"content":"\n\n最近在使用[mongoose](https://github.com/cesanta/mongoose)包装RESTful服务接口，内部系统是公司内部服务框架，通信协议都是二进制，每个服务的输入和输出都能自动绑定到JSON格式，和外部系统交互统一通过RESTful接口进行，在使用mongoose进行服务端和客户端基础库的包装时也发现这个库的一些不足。\n\n\n\n#### http请求例子\n\n通常的http请求头如下:\n\n```\nGET / HTTP1.1\\r\\n\nHost: 127.0.0.1:8080\\r\\n\n\\r\\n\n```\n简单的http回复头:\n\n```\nHTTP1.1 200 OK\\r\\n\n\\r\\n\n```\n\nmongoose是事件驱动一个库，使用mg_mgr_poll进行事件检测\n\n核心事件如下：\n\n```\n#define MG_EV_POLL 0    /* Sent to each connection on each mg_mgr_poll() call */\n#define MG_EV_ACCEPT 1  /* New connection accepted. union socket_address * */\n#define MG_EV_CONNECT 2 /* connect() succeeded or failed. int *  */\n#define MG_EV_RECV 3    /* Data has benn received. int *num_bytes */\n#define MG_EV_SEND 4    /* Data has been written to a socket. int *num_bytes */\n#define MG_EV_CLOSE 5   /* Connection is closed. NULL */\n#define MG_EV_TIMER 6   /* now \u003e= conn-\u003eev_timer_time. double * */\n```\n\n对注释进行一下翻译\n\n```\n#define MG_EV_POLL 0    /* 调用mg_mg_poll时向各个连接触发该事件（无参数） */\n#define MG_EV_ACCEPT 1  /* 服务器accept到新的连接产生该事件（参数为socket地址） * */\n#define MG_EV_CONNECT 2 /* 客户端连接服务器返回该事件（参数表示成功或者失败） *  */\n#define MG_EV_RECV 3    /* 收到数据（参数为已接收数据大小） */\n#define MG_EV_SEND 4    /* 数据已发送（参数为已发送数据大小） */\n#define MG_EV_CLOSE 5   /* 连接关闭触发该事件 */\n#define MG_EV_TIMER 6   /* 定时器事件* */\n```\n\n通常不会直接使用MG_EV_SEND，但是在调用msg_send函数（其它函数比如mg_printf都会调用mg_send进行数据发送）只是将数据添加到缓冲中，并不会真正发送，所以对大文件进行传输时不能一次性将所有数据塞入缓冲区，这会导致内存暴涨，合理做法是按chunk发送，发送完一个chunk后在MG_EV_SEND事件中进行下一个chunk的发送。\n\n对于一次普通的http请求，客户端使用mg_connet或者相关函数建立http连接后发送http头和内容，服务端收到MG_EV_REQUET，服务端使用mg_send或者相关函数发送回复，客户端收到MG_EV_REPLY事件，如果客户端是按chunked编码（tranfer-encoding: chunked）,那么服务端首先收到的是MG_EV_CHUNK（多个）事件，最后收到MG_EV_REQUET事件\n\n\u003e MG_EV_REQUET  \n\u003e MG_EV_REPLY  \n\u003e MG_EV_CHUNK\n\n基本步骤描述如下：\n\n1. 客户端发送请求\n2. 服务端收到MG_EV_REQUET\n3. 服务端进行回复\n4. 客户端收到MG_EV_REPLY\n\n#### 使用chunked方式编码变长数据\n\nhttp头：Transfer-Encoding: chunked\n\n如果是按chunk方式发送数据则描述如下:\n\n1. 客户端发送请求头（包含tranfer-encoding: chunked）\n2. 客户端使用mg_send_http_chunk或相关函数发送数据\n3. 服务端收到MG_EV_CHUNK\n4. 如果客户端还有chunk数据，回到2\n5. 服务端收到MG_EV_REQUET\n6. 服务端进行回复\n7. 客户端收到MG_EV_REPLY\n\n使用chunk方式发送数据，不用指定Content-Length头，[这里](http://www.jmarshall.com/easy/http/#http1.1c2)对chunk编码进行了详细说明\n\n\u003eChunked Transfer-Encoding  \n\u003e \n\u003eIf a server wants to start sending a response before knowing its total length (like with long script output), it might use the simple chunked transfer-encoding, which breaks the complete response into smaller chunks and sends them in series. You can identify such a response because it contains the \"Transfer-Encoding: chunked\" header. All HTTP 1.1 clients must be able to receive chunked messages.\n\u003e  \n\u003e A chunked message body contains a series of chunks, followed by a line with \"0\" (zero), followed by optional footers (just like headers), and a blank line. Each chunk consists of two parts:\n\u003e  \n\u003e a line with the size of the chunk data, in hex, possibly followed by a semicolon and extra parameters you can ignore (none are currently standard), and ending with CRLF.\nthe data itself, followed by CRLF.\nSo a chunked response might look like the following:\n\u003e \n\u003e HTTP/1.1 200 OK  \n\u003e Date: Fri, 31 Dec 1999 23:59:59 GMT  \n\u003e Content-Type: text/plain  \n\u003e Transfer-Encoding: chunked  \n\u003e \n\u003e 1a; ignore-stuff-here\n\u003e abcdefghijklmnopqrstuvwxyz  \n\u003e 10  \n\u003e 1234567890abcdef  \n\u003e 0 \n\u003e some-footer: some-value  \n\u003e another-footer: another-value  \n\u003e [blank line here]  \n\u003e \n\u003e Note the blank line after the last footer. The length of the text data is 42 bytes (1a + 10, in hex), and the data itself is abcdefghijklmnopqrstuvwxyz1234567890abcdef. The footers should be treated like headers, as if they were at the top of the response.\n\u003e \n\u003e The chunks can contain any binary data, and may be much larger than the examples here. The size-line parameters are rarely used, but you should at least ignore them correctly. Footers are also rare, but might be appropriate for things like checksums or digital signatures.\n\n头部\\r\\n\\r\\n结束后，就可以按chunk编码进行数据发送，每次先发送数据大小，16进制编码，使用\\r\\n换行,\\r\\n之前的非16进制编码内容会被忽略，接下来发送数据，数据可以是二进制，因为上一行已经指明的数据大小，数据发送完成使用\\r\\n结束当前chunk，使用0\\r\\n\\r\\n结束整个chunk编码。\n\nchunked与multipart的区别在SO的[这个回答](http://stackoverflow.com/questions/20334859/difference-between-multipart-and-chunked-protoccol)已经讲得非常清楚\n\n\u003e\n\u003eChunked is a transfer coding found in section 3.6 Transfer Codings.  \n\u003eMultipart is a media type found in section 3.7.2 Multipart Types a subsection of 3.7 Media Types.    \n\u003e...   \n\u003e This differs from the content-coding in that the transfer-coding is a property of the message, not of the entity.  \n\u003e...  \n\u003e Put more simply, chunking is how you transfer a block of data, while multipart is the shape of the data.\n\n简单来说chunked和multipart不是一个层面的东西，transfer-encoding表明的是数据编码的方式,Content-Type则描述的是媒体的类型。\n\n### websocket支持\n\nTranfer-Encoding有一种场景是实现服务器推送，服务端在一个连接中使用chunked方式进行数据编码，按一定频率发送chunk数据，但是不发送结束数据，服务器和客户端能够保持http长连接，实现服务器向客户端的数据推送。这种技术比客户端轮询进行数据更新的效率会高一些。对于服务器推送通过websocket技术，mongoose支持websocket v13，使用websocket包含必要的握手过程，流程如下：\n\n1. 客户端和服务器建立连接\n2. 客户端发送握手头\n3. 服务器回应握手结果，服务端触发MG_EV_WEBSOCKET_HANDSHAKE_DONE\n4. 客户端收到Sec-WebSocket-Accept:并触发MG_EV_WEBSOCKET_HANDSHAKE_DONE事件\n\nwebsocket支持全双工通信，客户端和服务之间都可以调用mg_send_websocket_frame或相关函数向远端发送数据，远端在MG_EV_WEBSOCKET_FRAME事件中读取帧数据。\n\nwebsocket是html5的新标准，如果在浏览器端做双向数据通信的话可以使用[socket.io](http://socket.io),socket.io保持了很好的浏览器兼容性，支持如下协议:\n\n- WebSocket\n- Adobe® Flash® Socket\n- AJAX long polling\n- AJAX multipart streaming\n- Forever Iframe\n- JSONP Polling\n\n在支持websocket的浏览器下优先使用websocket进行通信，使用socket.io提供的nodejs包可以非常简单地构建聊天应用，socket.io的应用能力目前并没有完全被开发出来。\n\n### 多段数据流\n\nmongoose支持multipart streaming，编译时通过定义MG_ENABLE_HTTP_STREAMING_MULTIPART宏来开启，使用多段数据流需要在头部指定:\n```\nContent-Type: multipart/...; boundary=JNhbAsdujgbjhasd\\r\\n\n```\n\nmultiparts数据使用头部指定boundary进行数据分段，没段的开始以\"--${boundary}\\r\\n\"开始,跟随一行数据处置头\"Content-Disposition:...\\r\\n\\r\\n\",然后是数据内容，理论上内容不能包含\"--${boundary}\"，以避免出现错误的数据边界识别，最后一\"--${boundary}--\\r\\n\"结束多段数据传输。\n\n一个多段数据传输的例子：\n\n```\nContent-Type: multipart/form-data; boundary=AsdsdgsdgASAFS\\r\\n\n\\r\\n\n--AsdsdgsdgASAFS\\r\\n\nContent-Disposition: name=a; filename=a.txt\\r\\n\n\\r\\n\n[content of a.txt]\n\\r\\n--AsdsdgsdgASAFS\\r\\n\nContent-Disposition: name=b; filename=b.txt\\r\\n\n\\r\\n\n[content of b.txt]\n\\r\\n--AsdsdgsdgASAFS--\\r\\n\n```\n\n服务端识别数据为多段数据（通过头Content-Type: multipart/），首先触发服务器的MG_EV_MULTIPART_REQUEST事件，之后循环处理每个数据块，对于每个数据块，包含三个关键事件：\n\n1. MG_EV_MULTIPART_BEGIN 段数据开始\n2. MG_EV_MULTIPART_DATA 段数据内容\n3. MG_EV_MULTIPART_END 段数据结束\n\nmongoose的缺点：\n\n1. 不够健壮，比如multipart的非法数据会导致mongoose访问越界\n2. 代码质量不是很高，代码编写的不是很规范\n3. 偏底层，需要熟悉http协议\n\nmongoose有点：\n\n1. 轻量，非常容易在宿主程序中内嵌web服务器\n2. 支持websocket（支持13版本）\n3. 提供大量示例，容易上手\n4. 事件驱动，io复用高\n5. 编程灵活性高，服务器和客户端公用一套代码库\n","cover":"","link":"use-mongoose-to-build-web-server.html","preview":"\u003cp\u003e最近在使用\u003ca href=\"https://github.com/cesanta/mongoose\"\u003emongoose\u003c/a\u003e包装RESTful服务接口，内部系统是公司内部服务框架，通信协议都是二进制，每个服务的输入和输出都能自动绑定到JSON格式，和外部系统交互统一通过RESTful接口进行，在使用mongoose进行服务端和客户端基础库的包装时也发现这个库的一些不足。\u003c/p\u003e\n","title":"使用mongoose构建web服务器"},{"content":"\n\n最近在把之前写的YASS(Yet Another Simlation System)项目拆成三个部分，分别是tbcore、tbui和tbengine，YASS在win下使用vs2015（早期是2010）开发，构建系统是msbuild，这次拆分索性把项目生成这块好好做一下，开始考虑cmake，但看过文档后对cmake的dsl实在是望而生畏，所以只有使用经验没有编写经验，premake可以作为一个非常优秀的选择（不少开源项目在用）。\n\n\n\npremake已经到5.0 Alpha版本，离正式发布应该不远了，暂时不支持Xcode、MonoDevelop、 Code::Blocks和CodeLite，等到是5.0正式发布的时候这些特性都会补全（5.0之前都是支持的）。\n\n使用premake基于如下几条原因:\n\n1. 对cmake的dsl实在无感，不如来门正儿八经的脚本痛快\n2. premake使用lua编写配置，足够简单，容易扩展\n3. 单执行文件，轻量，没有cmake笨重\n4. 支持的格式够用，vs2008~2005，GNU Make（包括Cygwin和MinGW），语言方面支持C、C++和C#\n5. 完善参考文档，初次上手使用起来就觉得非常简单，而且功能强大\n\n如果需要使用qt，[premake-qt](https://github.com/tizzybec/premake-qt)这个扩展能够实现，我在公司写了120+的项目生成脚本（为了兼容已有规则，400行左右），已经验证过其可用性（需要修改包导入的方式，可以看错误修改）。\n\n几个与vs相关的参数：\n\n1. 运行时库(/MD,/MDd),[runtime](https://github.com/premake/premake-core/wiki/runtime)\n2. 项目字符集(Unicode, MBCS),[characterset](https://github.com/premake/premake-core/wiki/characterset)\n\n几个坑:\n\n1. excludes会覆盖\n2. configuration废弃，建议使用filter，filter使用完以filter {} 结尾，关闭filter作用域\n3. 注意global、workspace和project之间的作用域覆盖情况\n4. 使用预编译头文件的时候需要写相对或者绝对路径，因为生成vs项目是使用的abspath进行比对，否则会出现预编译头文件无法创建的问题\n\n最后附带为我的个人项目[tbcore](http://git.oschina.net/tizzybec/tbcore)编写的[premake文件](http://git.oschina.net/tizzybec/tbcore/blob/master/premake5.lua?dir=0\u0026filepath=premake5.lua\u0026oid=429836ab0f3c2dcabeaf41708e78b46af1999542\u0026sha=4eaed5dc8cd782ecca595bcdefcf318349aecd75):\n\n```lua\n--\n-- tbcore 1.0 build script \n--\n\n------------------------------------------------------------\n\nworkspace \"All\"\n  platforms { \"x86\", \"x86_64\" }\n  configurations { \"debug\", \"release\" }\n  location \"build\"\n  \n------------------------------------------------------------\n\nproject \"tbcore\"\n  kind \"SharedLib\"\n  language \"C++\"\n  targetdir \"build\"\n  objdir \"%{cfg.location}/%{cfg.platform}/%{cfg.buildcfg}\"\n  \n  defines \n  {\n    \"TB_BASE_EXPORTS\", \n    \"TB_GEO_EXPORTS\", \n    \"TB_MATH_EXPORTS\", \n    \"TB_ARCHIVE_EXPORTS\", \n    \"TB_NETWORK_EXPORTS\", \n    \"TB_DB_EXPORTS\", \n    \"TB_UTILS_EXPORTS\", \n    \"TB_REFLECTION_EXPORTS\", \n    \"TB_RUNTIME_EXPORTS\"\n   }\n  \n  filter { \"platforms:x86\" }\n    architecture \"x86\"\n  filter { }\n  \n  filter { \"platforms:x86_64\" }\n    architecture \"x86_64\"\n  filter { }\n  \n  filter { \"configurations:Debug\" }\n    defines { \"DEBUG\", \"_DEBUG\"}\n    targetname \"tbcore-1.0-d\"\n    runtime \"Debug\"\n  filrer { }\n    \n  filter \"configurations:release\"\n    defines { \"NDEBUG\" }\n    optimize \"Speed\"\n    runtime \"Release\"\n    targetname \"tbcore-1.0\"\n  filter {}\n  \n  files \n  { \n    \"./src/**.hpp\", \n    \"./src/**.cpp\", \n    \"./src/**.inl\",\n    \"./include/**.hpp\",\n  }\n    \n  libdirs \n  { \n    \"./3rdparty/lib/%{cfg.platform}/%{cfg.buildcfg}\"\n  }\n    \n  excludes \n  { \n    \"**_test.cpp\" \n   }\n    \n  includedirs \n  {\n    \"./3rdparty/include\"\n  }\n   \n  links \n  { \n    \"srm.lib\", \n    \"rocksdb.lib\" \n  }\n\n------------------------------------------------------------\n\nproject \"tbcore_test\"\n  kind \"ConsoleApp\"\n  \n  files \n  { \n    \"**_test.cpp\", \n    \"src/testing/gmock/src/gmock_main.cc\"\n  }\n```\n\n### 参考资料\n\n1. premake5 wiki[https://github.com/premake/premake-core/wiki]\n2. lua 5.1 manual[http://www.lua.org/manual/5.1/manual.html]","cover":"","link":"use-premake5-generate-projects.html","preview":"\u003cp\u003e最近在把之前写的YASS(Yet Another Simlation System)项目拆成三个部分，分别是tbcore、tbui和tbengine，YASS在win下使用vs2015（早期是2010）开发，构建系统是msbuild，这次拆分索性把项目生成这块好好做一下，开始考虑cmake，但看过文档后对cmake的dsl实在是望而生畏，所以只有使用经验没有编写经验，premake可以作为一个非常优秀的选择（不少开源项目在用）。\u003c/p\u003e\n","title":"使用premake5进行项目生成"},{"content":"\n    \n上周的xxx-native-deskop的思考是一个非常初级的想法，最近又结合虚幻引擎界面设计和vczh的GacUI的思路进行了进一步思考。\n\n\n\nUI这块使用Qt最为后端的想法写完上篇之后就被我彻底摒弃了\n\n1. 和Qt窗口很难作数据映射，和MVVM的方式适配起来比较麻烦\n2. 如果这样做了可能就是另一个Qt Quick，但是quick这个东西实在是无感\n3. 窗口系统不可控，这也是虚幻、chromium、火狐各家实现自己的窗口系统的原因\n\n后来又想用vczh的GacUI，去github速览了一下源码，GacUI的设计和特性无疑是优秀的，能满足MVVM的方式，但是还是过于复杂，且还有一些坑没填完（TODO），最终还是舍弃了。然后我在想，既然了解Qt和虚幻的窗口设计，又熟悉web这一套界面实现方式，为什么不自己造个轮子呢，如此一来，上述所有问题应该能徒手解决吧。\n\n但这个轮子也不是凭空造的（全部凭空造的那是轮子哥），还是必须借用一些三方库来实现这些，初步选型：\n\n1. 脚本使用javascript，选择v8自然是没什么可说的了\n2. 后端2D绘制选用skia（chromium和火狐在使用，有部分使用经验，绘制性能和效果都不错）\n3. 前端vm库使用vuejs\n4. dom解析使用pugixml\n5. 窗口系统和前端绑定自己实现，窗口体系参考html5标准，样式使用css-layout库\n\n这样我们就有了一个最小的webkit实现，同时拥有扩展本地控件的能力（比如地图这类复杂控件）。\n\n[nova.js](http://novajs.com/index.html)给出的一个web component的例子\n\n控件代码\n``` html\n\u003c!-- 注册自定义元素\u003cmarkdown-editor\u003e --\u003e\n\u003ctemplate is=\"dom-module\"\u003e\n    \u003cstyle\u003e\n        :host {display:block;padding:15px 20px;border:1px solid rgba(16,16,16,0.1);background:white;}\n        textarea { width:100%; height:100px; resize:none;padding:5px;}\n    \u003c/style\u003e\n    \u003ctemplate\u003e\n        \u003ch3\u003eMarkdown Editor\u003c/h3\u003e\n        \u003ctextarea value=\"{{content::input}}\"\u003e\u003c/textarea\u003e\n        \u003cp\u003e\u003c/p\u003e\n    \u003c/template\u003e\n    \u003cscript require-src=\"components/nova-markdown/marked\"\u003e\u003c/script\u003e\n    \u003cscript\u003e\n        Nova({\n            is: 'markdown-editor',\n            props: {\n                content: {\n                    type: String,\n                    value: 'Hello Nova! '\n                }\n            },\n            createdHandler: function() {\n                this.on('_contentChanged', this.contentObserver);\n                this.render();\n            },\n            contentObserver: function(ev, oldVal, newVal) {\n                this.render();\n            },\n            render: function() {\n                this.querySelector('p').innerHTML = marked(this.content);\n            }\n        });\n    \u003c/script\u003e\n\u003c/template\u003e\n```\n使用Markdown控件\n``` html\n\u003cmarkdown-editor content=\"# Hello \\n Type some markdown here.\"\u003e\u003c/markdown-editor\u003e\n```\n\nvue-loader的一个例子\n\n![vue component template](/images/vue-component-with-pre-processors.png)\n\n其实Qt Designer的思路和上面有点类似，.ui文件有点像web component的声明，在编译期通过uic编译器编译为本地代码，在ui开发体验和性能上都照顾到了，但是有几个问题\n\n1. 忽略了数据的绑定过程，一旦生成界面文件(ui_xx.h，相当于view部分)，剩下的数据逻辑和显示逻辑几乎是混在在一块的，整个数据流在开发中没有很好的体现出来，当然Qt也提供Model模型，用于和View型的控件进行数据绑定，解耦显示和模型，实际用起来还是糅杂得比较紧密\n2. 控件的复用度是通过提升来实现的，也就是首先在Designer中有对应的控件基类，然后提升到某个用户自定义控件类，所见即所得的ui设计方式有助于减少上手的简易性，却无法降低程序逻辑组织的复杂度\n3. 显示样式没有和控件本身没有进行分离，导致部分样式设置放置在.ui文件中，部分放置在控件代码内（.ui文件的样式配置最终也是以代码的方式体现），显示配置没有很好地分离出来，导致修改主题要么重写style，要么使用支持有限的stylesheet，两者结合起来使用往往会出现和预期不一致的效果（这个看经验了）\n\n前面还没有提及对数据变化的管理，从目前前端去世来看，单一状态组件确实是比较好的思路，对于撤销重做这样的特性简直信手拈来 ，对于组件来说，有状态传入和传出，并不涉及对状态的直接修改，对于传出状态的回写需要在于状态管理方处理（store）。这点我后端的框架是能够非常好地支持，基本上前端的一些解决思路在现有的后端框架中都有所体现，所以前端这么玩也没有问题，部分对性能要求极高的部分可能还会放在后端来实现。\n\n前端主要负责显示逻辑，数据逻辑还是来自后端，前端可以通过js绑定的获取数据，后端会建立数据对象监视器，对新数据进行检测，初始化时前段根据数据类型编写数据模板填充代码，进行首次渲染，后端出现数据变化，会触发前段数据变化通知回调，前段再根据变化编写对象的显示变化代码。\n\n使用web作为前段主要是为了调试和编写方便，应用发布的理想方式是在正式发布前将前段代码转换为c++代码（根据js的ast树进行代码转换），这部分工作依赖性能测试的结果，如果性能在可接受的范围内，可以忽略代码转换，如果需要将性能提升到机制，那么在代码转换这块必须作出投入来减少开发便利带来的性能损失。\n\n\n","cover":"","link":"rethink-vue-desktop.html","preview":"\u003cp\u003e上周的xxx-native-deskop的思考是一个非常初级的想法，最近又结合虚幻引擎界面设计和vczh的GacUI的思路进行了进一步思考。\u003c/p\u003e\n","title":"对vue-desktop的进一步思考"},{"content":"\n\n最近在思考如何基于web开发方式做一个本地应用开发框架，兼具性能和开发体验。首先毙掉hybird app的方式，比如phonegap、titanium和electron这种方案，webview做的事情太多，很多环节不可控，同时无法和本地控件进行混合使用。\n\n\n\nreact-native的虚拟DOM思路个人是非常喜欢的，但是函数式方式比起mvvm的方式，代码上没有mvvm简洁，同时很多使用习惯上也有很多转变，最重要的是没有desktop版本（桌面版本是最近非常需要的）。\n\n最近也在关注vuejs，淘宝15年双十一爆出了weex，看分享是react-native的vue版本，简称vue-native，离weex开源的时间已经不多了，阿里的同学加油啊。\n\nweex和我需要的东西已经非常接近了，但是还是有问题:\n\n1. 淘宝的开源都是业务优先，掺杂了过多的东西，维护也是个问题\n2. 还是没有desktop\n\n虽然desktop用hybird的方式也不差，因为机器性能本身很高，但是考虑到和本地控件还有项目本身的宿主语言交互，这个就还是不现实了。\n\nrn和weex都是virtual dom+js bridge实现，rn是函数式的方式，而weex是mvvm的方式（使用了vue的数据监听和依赖收集，还使用mustache模板引擎），rn用的是JavascriptCore作为js引擎，weex选择了v8。\n\nweex的几篇文章\n\n- [对无线电商动态化方案的思考（一）](https://github.com/amfe/article/issues/13)\n- [对无线电商动态化方案的思考（二）](https://github.com/amfe/article/issues/14)\n- [对无线电商动态化方案的思考（三）](https://github.com/amfe/article/issues/15)\n\n使用web开发方式是为了解决开发效率的问题，这包含两个问题：\n\n1. 开发和调试工具的支持（现在没有比web开发的工具集和可用方案更丰富的吧）\n2. 技术上的可达性和更广泛的受众（现在懂点web的多了，很多概念都不用重复解释了，到业务层最好是傻瓜化）\n\n做框架最重要的是生态，当然某些独角兽的大公司例外，可以创造生态，更多的开发者还是向更好的生态靠拢，毕竟长期的支持和开发者的活力是做开源重要的一步。\n\n对于桌面端，目前的跨平台的可用方案很多，有hybird的，当然我暂时是不会考虑的，因为我后续想做的东西更多地还是在native c++ 下做的，所以需要一个c++的界面后端，目前来说好的选择并不是很多，时间充足的话何以像unreal engine一样写个multicast-delegate版本的界面库，但是成本实在是太大了，可以暂时选用Qt作为界面后端，后期性能和灵活性上不满足再适配其它引擎。\n\n所以我理解的xxx-native-desktop框架分为四层:\n\n1. vm层，负责界面逻辑和数据变化监视\n2. virtual-dom层，负责虚拟dom到真实dom的映射\n3. js \nbridge层完成js逻辑到本地逻辑的映射，主要是数据变化和事件响应。在这一层，js操作的数据变化会触发本地的数据变化；js触发的事件会转发到本地进行事件处理。\n\nvm层目前考虑的是vue，因为接口很讨喜，足够简单，官方文档已经有组件模块化的支持，webcomponent分为三个部分，模型、模板和样式。\n\n- 模板遵从webomponent的方式，直接使用控件标签，语意性更好，同时拥有有限的属性支持。样式这块考虑使用facebook的css-layout作为样式支持，当然可能需要进行扩充。\n\n- 模型这块由vm完成数据的监视和本地数据的状态的同步。\n\n- 桥接这块比较偏向于使用v8，性能优先。\n\n``` html\n\u003cListView class=\"demo-list-view\"\u003e\n\u003c/ListView\u003e\n\u003cstyle\u003e\n  ... style here\n\u003c/style\u003e\n\u003cscript\u003e\n  ... vm code here\n\u003c/script\u003e\n```\n\n这次的思考更多的是想把xxx-native这个东西和后端的c++ 应用作一个结合，主体是c++，数据源也是从c++ 这边过来的，web这一层作为界面显示逻辑的开发层，也可以理解为纯显示业务层。对性能要求更高的部分可以用native c++ 包装出更强大，性能更好的控件，同时映射到webcomponent，也可以对性能要求极高的部分直接使用本地c++编码，这是开发效率和产品性能之间的权衡，选用本地界面库实现而不是hybird也正是这个考虑。\n\n对于数据的映射和样式的同步，我们需要足够快的js解析器和样式解析器，以保证最高的转换效率，将web开发方式带来的性能损失降低到最小。整个应用显示层都是数据驱动的，所以也是一个reactive风格的ui框架。\n\n对于数据变化的监视本身我们在后端是有一层属性变化监视服务，如果数据来自前端，则数据变化的监视工作交给vue来做，后端接受到的是最后的数据变化，如果直接使用后端的变化监视，前端也可以响应数据变化事件来触发对应的逻辑。对于数据监视的职责可以全部放在前端也可以直接放在后端，对于性能要求高的场景，建议直接使用后端的数据监视服务，性能上更有保证。前端通过数据订阅的方式来响应数据的变化并进行处理。对于数据监视这个点还需要辅以相当数量的场景和性能测试。\n\n下一步需要把webcomponent的规范进一步细化，确定js bridge交互的部分（数据和样式），然后是技术选型，最后进入实际的开发阶段。\n\n写到这里真想把这个玩意叫做reactive-vue-native-desktop(rvnd).\n\n\n","cover":"","link":"xxx-native-desktop.html","preview":"\u003cp\u003e最近在思考如何基于web开发方式做一个本地应用开发框架，兼具性能和开发体验。首先毙掉hybird app的方式，比如phonegap、titanium和electron这种方案，webview做的事情太多，很多环节不可控，同时无法和本地控件进行混合使用。\u003c/p\u003e\n","title":"关于 xxx-native-desktop 的思考"},{"content":"\n\n最近在研究finagle，打算先从scala语言开始学习。本文不能作为scala的入门教程，内容也不尽完善和准确，只是作为个人学习笔记之用。\n\n\n\n## scala观点\n- [Scala语言设计有哪些缺陷?](https://www.zhihu.com/question/28573046)\n- [为什么说 Scala 是 JVM 上的 C++？](https://www.zhihu.com/question/27332932)\n- [为啥 Erlang 没有像 Go、Scala 语言那样崛起？](https://www.zhihu.com/question/38032439)\n- [Scala 是一门怎样的语言，具有哪些优缺点？](https://www.zhihu.com/question/19748408)\n- [有趣的 Scala 语言: 函数成了一等公民](http://www.ibm.com/developerworks/cn/java/j-lo-funinscala3/index.html)\n\n一个有趣的观点\n ![图片来自zhihu.com，侵删](/images/scala-view-point.png)\n\n## Scala学习资源\n- [Scala与Clojure函数式编程模式：Java虚拟机高效编程](http://product.dangdang.com/1349099431.html)\n- [深入理解Scala](http://product.dangdang.com/23630366.html)\n- [Scala课堂](http://twitter.github.io/scala_school/zh_cn/index.html)\n- [Scala语言官方站点](http://docs.scala-lang.org/)\n- [Effective Scala](http://twitter.github.io/effectivescala/index-cn.html)\n- [官方编码规范](http://docs.scala-lang.org/style/)\n- [Scala api reference](http://www.scala-lang.org/api/current/#package)\n\n## 构建基本的scala环境\n\n### windows\n\n由于的代理服务器不是很稳定，所以使用typesafe的[activator](http://www.lightbend.com/activator/download)作为开发构建工具，兼容sbt的所有命令\n\n### Mac\n\ntypesafe会搜寻如下文件夹进行执行\n\n- Sources in the base directory\n- Sources in src/main/scala or src/main/java\n- Tests in src/test/scala or src/test/java\n- Data files in src/main/resources or src/test/resources\n- jars in lib\n\n### IDE\n推荐IntelliJ Idea，支持sbt构建工具\n[下载地址](https://www.jetbrains.com/idea/download/)\n\n### activator环境测试\n输入`activator shell`进入shell模式，`console`进入scala的repl。\n\n建立src\\main\\scala\\helloworld.scala文件，编写测试代码\n\n``` scala\nobject Hi {\n  def main(args: Array[String]) = println(\"Hello world!\")\n}\n```\n\n在shell模式下执行`run`，输出\"Hello world!\"，基本scala编译环境准备完成，这里不对sbt作过多的学习。\n\n## 基础部分\n\n### 内置类型\n![scala type hierarchy](/images/scala-type-hierarchy.jpg)\n\n### 定义可变变量\n``` scala\nvar variableType : String = \"123\"\n```\n\n### 定义不可变变量\n``` scala\nval constVariableType : Int = 123\n```\n\n### 函数\n不带参数时括号可以省略，返回类型可以被推导时可以省略返回值类型。\n``` scala\ndef noneParamFunction = \"123\"\ndef noneParamWithReturnType : String= \"123\"\ndef onePramWithReturnType(i : Int) = i + 1\ndef functionDefinationSpanTwoLine(i : Int) = {\n   val a = i + 1\n   a + 1\n}\n```\n\n返回值为空的函数\n``` scala\ndef nullReturnValueFun={} //f:Uint`\n```\n\n使用`=\u003e`创建匿名函数，匿名不需要制定返回值。\n``` scala\n(i : Int) =\u003e i + 1\n```\n\n### 注释\n和C++一样，支持//和/*...*/\n\n### 流程控制\n直接把语法定义搬过来\n\n    `if' `(' Expr `)' {nl} Expr [[semi] `else' Expr]\n    `while' `(' Expr `)' {nl} Expr\n    `try' (`{' Block `}' | Expr) [`catch' `{' CaseClauses `}'] [`finally' Expr]\n    `do' Expr [semi] `while' `(' Expr ')'\n    `for' (`(' Enumerators `)' | `{' Enumerators `}') {nl} [`yield'] Expr\n    `throw' Expr\n    `return' [Expr]\n\n### 关键字\n\u003e abstract case catch class def  \ndo else extends false final  \nfinally for forSome if implicit  \nimport lazy macro match new   \nnull object override package private   \nprotected return sealed super this   \nthrow trait try true type   \nval var while with yield   \n_ : = =\u003e \u003c- \u003c: \u003c% \u003e: # @  \n\n***注意：***在scala中访问java标识符含有scala关键字式用``进行转义。\n\n### 表达式\n\u003eScala中（几乎）一切都是表达式\n\n### 包Package\n\n#### 声明包\n``` scala\npackage myFirstPackage\n```\n\n#### 支持嵌套\n``` scala\npackage com {\n    package tizzybec {\n        package toy {\n            ...\n        }    \n    }\n}\n```\n\n#### 引用包\n\n引用制定成员\n``` scala\nimport java.awt.Color\n```\n\n引用所有成员\n``` scala\nimport java.awt._\n```\n\n引用部分成员\n``` scala\nimport java.awt.{Color, Font}\n```\n\n给成员别名\n``` scala\nimport java.util.{HashMap =\u003e JavaHashMap}\n```\n\n使用别名和部分成员可以达到吟唱部分包的目的\n``` scala\nimport java.util.{HashMap =\u003e _, _} \n```\n\n对于当前包宇引入包内成员名字重名的情况使用`_root_`指向包的根部来引用当前包内的制定成员\n\n### 对象Class\n\nclass定义与java相似\n``` scala\nclass myFirstScalaClass {}\n```\n\n单例模式支持\n``` scala\nobject SingletonClass\n```\n\n私有变量，同名的class和object互为友元\n``` scala\nclass ObjectHasPrivateMember {\n    import ObjectHasPrivateMember ._\n\n    def privateMember = realPrivateMember\n}\n\nobject ObjectHasPrivateMember {\n    private def readPrivateMember = 12\n}\n```\n\n### 异常支持\n异常支持应该是为了兼容java库的使用，除非使用java带异常函数，个人很少使用异常\n\n``` scala\nval result: Int = try {\n        remoteCalculatorService.add(1, 2)\n    } catch { \n         case e: ServerIsDownException =\u003e { log.error(e, \"the remote calculator service is unavailable. should have kept your trusty HP.\") 0 }\n    } finally { \n        remoteCalculatorService.close()\n    }\n```\nscala的异常是表达式级别的，支持finally，支持模式匹配\n\n### 与java的互操作性\n如果对scala生成的代码有疑问，使用JDK自带的javap反编译工具进行查看，由于我对java字节码不是很熟悉，这里就不深入了\n\n具体操作规则略。\n\n## 特性trait\n\n特性和java/C++中的虚函数属于同等概念，trait定义的接口可实现也可以不实现\n\ntrait可以从class继承，通过with进行mixin（混入），从scala-lang引入一个例子\n\n``` scala\nabstract class AbsIterator{\n    type T\n    def hasNext:Boolean\n    defnext: T\n }\n\ntrait RichIterator extends AbsIterator {\n    defforeach(f: T =\u003e Unit) { while(hasNext) f(next) }\n}\n\nclass StringIterator(s: String) extends AbsIterator {\n    type T = Char\n    private var i =0\n    def hasNext = i \u003c s.length()\n    def next = { val ch = s charAt i; i +=1; ch }\n}\n\nobject StringIteratorTest {\n    def main(args:Array[String]){\n        class Iter extendsStringIterator(args(0)) with RichIterator\n        val iter = newIter\n        iter foreach println\n    }\n}\n```\n\n通过使用`with RichIterator`，Iter 混入了RichIterator的行为，也就是mixin-class composition，对于不支持多重继承的语言，mixin能够很好突破这个限制，对mixin理解为内联还是ducktype的语法糖呢？\n\n延伸阅读：[Mixin是什么概念](https://www.zhihu.com/question/20778853)\n\n## 集合collection\n\nscala对集合的支持非常完善，很适合进行大数据的处理。集合主要分为四类\n\n- 链表List\n- 集Set\n- 序列Seq\n- 映射map\n\n这几类是基类，在scala中有更多的用途的集合。\n\n所有集合都拥有以下特质\n\n- 可遍历性，Traversable特质，定义了map、foreach、find、filter、partition和groupBy等函数\n- 可迭代性，Iterable特质，定义了hasNext和next等函数\n\n集合严格区分mutable和immutable，不可变特性是函数式编程中经常使用，可变状态会带来线程安全问题\n\n## 注解\n\nscala在注解的使用上基本和java保持一致，这个特性是在JDK1.5以后引入的，注解相当于代码的元数据，scala常用的注解包括：\n\n- cloneable\n- inline\n- native\n- remote\n- serializable\n- throws\n- transient\n- uncheked\n- volatile\n\n这篇文章[Scala基础之注解(annotation)](http://roadtopro.me/scala/annotation/)讲了常用注解的使用\n\n用上注解就有点c++的味道了，比起c++，在写法上更具一致性，像Deprecated，c++里只能只能以来各个编译器的隐含特性，tailrec支持尾递归优化就实在是太赞了，还有像transient对属性进行注解能更加精准地控制序列化的过程，c++里面撸reflection和serialization可就全靠hack手段了（全是宏和模板）\n\n## 函数式编程\n### 柯里化\nscala对currying的支持非常好，直接定义参数链就可以：\n\n``` scala\ndef curryingFunc(i: Int)(j :  String)\n```\n\n### 函数组合\n\n组合函数直接内置compose关键字进行支持\n\n``` scala\ndef f(s String): String = \"f(\" + s + \")\"\ndef g(s: String): String= \"g(\" + s + \")\"\ndef fComposeG = f _ compose g _\nfComposeG (\"x\")  //return f(g(x))\n```\n\nscala提供一个和compose相反调用顺序的函数andThen ，改写上面的例子\n\n``` scala\ndef f(s String): String = \"f(\" + s + \")\"\ndef g(s: String): String= \"g(\" + s + \")\"\ndef fAndThenG = f _ andThen g _\nfAndThenG (\"x\")  //return g(f(x))\n```\n\n### 偏函数（partial function）\n\n先看看函数和偏函数的差异：\n \n\u003e 对给定的输入参数类型，函数可接受该类型的任何值.\n\u003e 对给定的输入参数类型，偏函数只能接受该类型的某些特定的值\n\n偏函数支持调用isDefinedAt方法查询是够支持给定参数，偏函数的一个特例就是case语句，case本身就是偏函数的一个子类\n\n使用orElse可以对偏函数进行组合，语句从第一个偏函数开始匹配直到匹配输入，或者到达最后一个orElse\n\n``` scala\nval partial = one orElse two orElse three orElse wildchar\n```\n\n上述语句先检查one是够接受参数，然后是two，然后是three，如果均没有匹配则匹配最后的通配符wildchar\n\n偏函数是函数的子类型，任何接受函数参数的地方均接受偏函数\n\n## 泛型\n\n### 类型推导\nScala有秩1多态性(未查到)，下面的代码无法编译通过\n\n``` scala\ndef foo[A](f: A =\u003e List[A], i: Int) = f(i)\n```\n\n如果拿C++改写，可能是这样的（徒手码的）\n\n``` scala\ntemplate \u003ctypename A\u003e\nstd::list\u003cA\u003e foo(std::list\u003cA\u003e (const *f)(A), const A \u0026i) {\n    return f(i);\n}\n```\n\nC++编译器能够正常推导所有类型\n\n在scala school中有这么一句话：\n\n\u003e 在Scala中所有类型推断是局部的。Scala一次分析一个表达式。\n\n我们可以理解为scala编译器分别对`f: A =\u003e List[A]`和`i: Int`进行了推导，但是没有对f(i)进行联合推导，这点从C++过来的多多少少有些不适应。\n\n## 模式匹配\n使用函数式语言，模式匹配的支持确实给代码的编写带来很多便利，scala通过match关键字进行模式匹配，看一个例子\n``` scala\nval times = 1\ntimes match {\n  case 1 =\u003e \"one\"\n  case 2 =\u003e \"two\"\n  case _ =\u003e \"some other number\"\n}\n```\n### 类型匹配支持\n``` scala\ndef bigger(o: Any): Any = {\n  o match {\n    case i: Int if i \u003c 0 =\u003e i - 1\n    case i: Int =\u003e i + 1\n    case d: Double if d \u003c 0.0 =\u003e d - 0.1\n    case d: Double =\u003e d + 0.1\n    case text: String =\u003e text + \"s\"\n  }\n}\n类成员匹配，和if语句差不过\n``` scala\ndef calcType(calc: Calculator) = calc match {\n  case _ if calc.brand == \"hp\" \u0026\u0026 calc.model == \"20B\" =\u003e \"financial\"\n  case _ if calc.brand == \"hp\" \u0026\u0026 calc.model == \"48G\" =\u003e \"scientific\"\n  case _ if calc.brand == \"hp\" \u0026\u0026 calc.model == \"30B\" =\u003e \"business\"\n  case _ =\u003e \"unknown\"\n}\n```\n### 样本类（Case classes）匹配\n``` scala\ncase class Calculator(brand: String, model: String)\nval hp20b = Calculator(\"hp\", \"20B\")\nval hp30b = Calculator(\"hp\", \"30B\")\ndef calcType(calc: Calculator) = calc match {\n    case Calculator(\"hp\", \"20B\") =\u003e \"financial\"\n    case Calculator(\"hp\", \"48G\") =\u003e \"scientific\"\n    case Calculator(\"hp\", \"30B\") =\u003e \"business\"\n    case Calculator(ourBrand, ourModel) =\u003e \"Calculator: %s %s is of unknown type\".format(ourBrand, ourModel)\n}\n```\n## 协变，逆变\n关于逆变和协变，可以参考以下博客进行学习\n[Java中的逆变与协变](http://www.cnblogs.com/en-heng/p/5041124.html)\n\n这里摘出几个要点\n### 定义\n\n\u003e 逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果A、B表示类型，f(⋅)表示类型转换，≤表示继承\u003e关系（比如，A≤B表示A是由B派生出来的子类）；  \n\u003e f(⋅)是逆变（contravariant）的，当A≤B时有f(B)≤f(A)成立；  \n\u003e f(⋅)是协变（covariant）的，当A≤B时有f(A)≤f(B)成立；  \n\u003e f(⋅)是不变（invariant）的，当A≤B时上述两个式子均不成立，即f(A)与f(B)相互之间没有继承关系。\n\n### 理解\n\n\u003eextends确定了泛型的上界，而super确定了泛型的下界\n\n### 区分\n\n\u003e PECS原则：producer-extends, consumer-super.\n\n### 示例\n\n``` java\npublic static \u003cT\u003e void copy(List\u003c? super T\u003e dest, List\u003c? extends T\u003e src)\n...\n```\n\n理解了协变确定了泛型的上界，逆变确定了类型的下界，逆变和协变基本就理解清楚了\n\n回到scala的协变和逆变，举一个scala内置单参数函数的trait定义\n\n``` scala\ntrait Function1 [-T1, +R] extends AnyRef\n```\n\n可以理解为函数参数传入是逆变的，函数返回值是协变的\n\n在支持协变和逆变语法的基础上，scala支持类型边界，在泛型编程中通过指定类型的边界，结合逆变协变的语法可以作类型约束\n\n### 通配符_\n_可以在模板中匹配类型\n``` scala\ndef count(l: List[_]) = l.size //ignore list element type\n```\n\n也可以在Partial application模拟std::bind的语法，从旧的函数中通过部分参数绑定得到新的函数\n``` scala\ndef adder(m: Int, n: Int) = m + n\nval add2 = adder(2, _:Int)\n```\n\n这和在javascript中经常会使用闭包特性返回部分应用后的新函数是类似的东西\n\n## 对monad的理解\n\n参考：http://hongjiang.info/semigroup-and-monoid/\n\n1. 封闭性（Closure）：对于任意a，b∈G，有a*b∈G \n2. 结合律（Associativity）：对于任意a，b，c∈G，有（a*b）*c=a*（b*c） \n3. 幺元 （Identity）：存在幺元e，使得对于任意a∈G，e*a=a*e=a \n4. 逆元：对于任意a∈G，存在逆元a^-1，使得a^-1*a=a*a^-1=e\n\n**半群（semigroup）：**满足封闭性和结合律\n\n**幺半群（monoid）：** 是半群且有幺元。\n\n**函数(morphism)：**类型之间的映射。\n\n**范畴：**一组类型的集合，为了理解可简单理解为高阶类型。\n\n**函子（functor）：**\n一个范畴内的元素可以映射为另一个范畴的元素，且元素之间的关系也可以映射为另一个范畴的关系。对于范畴C1和C2有\n\n1. 将C1中的类型 T 映射为 C2 中的 List[T] :  T =\u003e List[T]\n2. 将C1中的函数 f 映射为 C2 中的 函数fm :  (A =\u003e B) =\u003e (List[A] =\u003e List[B])\n\n通常带有map方法的类型构造器就是一个函子。\n\n**自函子（endfunctor）：**将范畴映射到自身的函子。\n\n**单子（monad）：**自函子范畴上的一个幺半群。\n\n## 和C++对比\n### 优点:\n1. 对函数式编程的支持\n2. 模式匹配（包括类匹配）能够写出更加简洁的代码\n3. 支持高阶函数，C++通过bind和function来模拟其实也问题不大\n4. 比C++更加强大的类型推导系统\n5. 支持Mixin，通过traits\n6. 对类型反射的支持\n7. 包比namespace好用，模块化管理\n8. 支持注解，目前来说注解还是个好东西\n9. 具名参数，C++没有真是遗憾\n10. 对于集合的非常强大\n11. 对可变参数简单\n12. 可以复用jvm上的很多软件包\n13. 大数据软件多数是基于scala写的\n\n### 缺点：\n1. 过于复杂的语法和操作符\n2. 过多的隐式类型转换，隐式转换用起来会很爽\n3. 不同版本的jar二进制不兼容\n4. 写完全暴露给java调用的代码比较困难，强制scala技术栈\n5. 太灵活了，有时候也是缺点\n","cover":"","link":"scala-tutorial-for-cpp-programmer.html","preview":"\u003cp\u003e最近在研究finagle，打算先从scala语言开始学习。本文不能作为scala的入门教程，内容也不尽完善和准确，只是作为个人学习笔记之用。\u003c/p\u003e\n","title":"面向c++程序员的scala教程"},{"content":" \n\n之前看公司有人收集类元信息用的方法很巧妙，所以早就想写一篇关于动态初始化的博客，一则是想分享，二则是作为个人摘记。\n\n\n\n\n在c++标准的initialization of non-local variable章节有如下描述\n\n\u003e There are two broad classes of named non-local variables: those with static storage duration (3.7.1) and  \nthose with thread storage duration (3.7.2). Non-local variables with static storage duration are initialized  \nas a consequence of program initiation. Non-local variables with thread storage duration are initialized as a  \nconsequence of thread execution. Within each of these phases of initiation, initialization occurs as follows.  \n\u003e Together, zero-initialization and constant initialization are called static initialization ; all other initialization is   \ndynamic initialization . Static initialization shall be performed before any dynamic initialization takes place. Dynamic initialization   \nof a non-local variable with static storage duration is either ordered or unordered. Definitions of explicitly specialized class template  \nstatic data members have ordered initialization.   \n\u003e It is implementation-defined whether the dynamic initialization of a non-local variable with static storage  \nduration is done before the first statement of main. If the initialization is deferred to some point in time  \nafter the first statement of main, it shall occur before the first odr-use (3.2) of any function or variable  \ndefined in the same translation unit as the variable to be initialized.  \n\n非局部静态变量的初始化是否发生在主函数main之前则以依赖于编译器的实现,在msdn上能看到如下文档\n\n\u003e C Run-Time Error R6030  \nCRT not initialized  \nThis error occurs if you are using the CRT, but the CRT startup code was not executed.   \nIt is possible to get this error if the linker switch /ENTRY is used to override the   \ndefault starting address, usually mainCRTStartup, wmainCRTStartup for a console   \nEXE,WinMainCRTStartup or wWinMainCRTStartup for a Windows EXE, or _DllMainCRTStartupfor a DLL.  \nUnless one of the above functions is called on startup, the C Runtime will not be initialized.  \n\n比如我们使用vc100编译器，默认的入口函数wmainCRTStartup，当然项目配置或者链接器提供/ENTRY参数进行入口函数的指定，对于DLL又有所不同，执行的_DLLMainCRTStartup函数，一般来说这些函数做了如下事情\n\n\u003e including calling _CRT_INIT, which initializes the C/C++ run-time library and invokes C++ constructors on static, non-local variables  \n\n所以对于VC系列编译器CRT提供了动态初始化的实现,在CRT Initialization文档部分,我们看到如下描述\n\n\u003e By default, the linker includes the CRT library, which provides its own startup code. This startup code initializes the CRT library,   \ncalls global initializers, and then calls the user-provided main function for console applications.  \n\n并且提供一段示例代码\n\n```\nint func(void)  \n{  \n    return 3;  \n}  \n  \nint gi = func();  \n  \nint main()  \n{  \n    return gi;  \n}  \n```\n\n通过dumpbin /all your.obj可以看到所有放置在.CRT$XCA 和 .CRT$XCZ之间的.CRT$XCU内变量都会进行全局初始化。我们暂时不看dumpbin出来的具体内容，稍后我们会结合自己写的例子进行说明。\n\n回到文章开头,为什么要用动态初始化来进行元数据的收集?我的理解至少有两点便利:\n\n1.  在main函数或者在DLL全局函数执行之前所有类的元信息已经收集完毕，无论是对类进行序列化还是反序列化都有足够的信息\n\n2.  通过一些trick我们可以不定义全部变量来进行元信息的收集，这样避免了声明过多的全局变量，同时整个注册部分完全隐藏了起来，通过宏的包装,完全可以简化元信息收集\n下面我们来看一看具体的实现。\n\n首先申明一个不完全类型的元信息收集器：\n\n```\ntemplate\u003cclass Ty\u003e  \nstruct MetaDataCollector;  \n```\n\n然后声明一个激活器来激活元信息收集器\n\n```\ntemplate \u003cclass T\u003e\nclass Activator {\n public:\n  static T\u0026 Activate() {\n    Magic(ins_);\n    static T a;\n    return a;\n  }\n private:\n  static void Magic(const T\u0026 x) { (void)x; };\n  static T\u0026 ins_;\n};\n\ntemplate \u003cclass T\u003e\nT\u0026 Activator\u003cT\u003e::ins_ = Activator\u003cT\u003e::Activate();\n```\n\n最后定义一个进行类数据收集的宏，我们假设每个要注册的类都提供一个RegType函数进行信息收集\n\n```\n#define REGCLASS(cls) \\  \ntemplate\u003c\u003e\\  \nstruct MetaDataCollector\u003ccls\u003e{\\  \n    MetaDataCollector()\\  \n    {\\  \n        cls::RegType();\\  \n    }\\  \n    static void Use()\\  \n    {\\  \n        Activator\u003c MetaDataCollector\u003ccls\u003e \u003e::Activate();\\  \n    }\\  \n}  \n```\n\n把这几段代码编成动态库给其它程序调用，之后我们新建一个项目，新建一个类C，并且对类进行元信息收集\n\n```\nclass __declspec(dllexport) C{  \npublic:  \n    static void RegType(){  \n          \n    };  \n};  \n  \nREGCLASS(C);  \n```\n\n通过调试，我们顺利在GetInstance函数内得到断点，调用堆栈中显示了Dynamic initializtion字样\n\n```\n\u003e    MyMain.exe!`dynamic initializer for 'Activator\u003cMetaDataCollector\u003cC\u003e \u003e::ins_''()  行 28 + 0x28 字节 C++  \n```\n\n同时查看obj的dump输出在..CRT$XCU组内看到了需要动态初始化的变量\n\n```\nOffset    Type              Applied To         Index     Name  \n--------  ----------------  -----------------  --------  ------  \n00000000  DIR32                      00000000        47  ??__E?ins_@?$Activator@U?$MetaDataCollector@VC@@@@@@2U?$MetaDataCollector@VC@@@@A@@YAXXZ (void __cdecl `dynamic initializer for 'public: static struct MetaDataCollector\u003cclass C\u003e Activator\u003cstruct MetaDataCollector\u003cclass C\u003e \u003e::ins_''(void))  \n```\n\n可以看到 **ins_** 进行了动态初始化，通过定义宏可以看到这种实现还是比较优雅的，元信息类的初始化放在了单例类中,但是需要注意的初始化ins_的过程中调用的Activator函数必须使用ins_静态成员变量，否则模板类是无法触发Activate方法来实例化对象实例。\n\n综合以上实现,我们用到了不完整类型定义元信息收集器，通过宏来定义具体的元信息收集器进行模板的激活，模板激活的过程中发现有静态成员变量需要初始化，\n则首先调用Activator函数,如果Activator函数内没有任何影响静态变量值的代码，则无法触发静态初始化，类型实例也无法无法激活。\n\n原因解释在c++标准中\n\n\u003e An implementation is permitted to perform the initialization of a non-local variable with static storage  \nduration as a static initialization even if such initialization is not required to be done statically, provided  \nthat  \n-   the dynamic version of the initialization does not change the value of any other object of namespace  \nscope prior to its initialization, and  \n-   the static version of the initialization produces the same value in the initialized variable as would be  \nproduced by the dynamic initialization if all variables not required to be initialized statically were  \ninitialized dynamically.  \n","cover":"","link":"cpp-dynamic-initializer.html","preview":"\u003cp\u003e之前看公司有人收集类元信息用的方法很巧妙，所以早就想写一篇关于动态初始化的博客，一则是想分享，二则是作为个人摘记。\u003c/p\u003e\n","title":"C++动态初始化（Dynamic Initializer）"},{"content":" \n\n## 建站缘由\n\n由于在一家涉密机构工作，工作两年一直没有将技术学习过程和成果以博客形式分享出来（一直零散地写在有道笔记里，不成体系）。恰巧最近外甥在学习[React Native](https://facebook.github.io/react-native/),有些不明白的地方在不断请教我，借此机会我也搭建了react-native相关环境，对react/react-native有些比较基本的理解，由于使用过程中难免会有问题，所以想以此博客记录疏漏，同时激励自己将写博客这件事情坚持下去。\n\n之前无意中看到一款不错的静态博客，源自一款流产的产品，使用go语言编写，帮助文档简洁明了，于是就决定作为新博客的构建工具，搭建在github上，同时购置了域名[www.tizzybec.com](http://www.tizzybec.com)定向至github pages.\n\n![纸小墨 - 简洁的静态博客构建工具](/images/ink.png)\n\n## 搭建过程\n\n### 建立github pages\n\n- 创建一个新的reponsitory，取名`tizzybec.github.io`（tizzybec是我的英文id），\n- 进入settings，在Github Pages部分，点击`Launch automatic page generator`覆盖原有网站，否则就不能用`tizzybec.github.io`来访问博客主页\n- 进入`tizzybec.github.io`即可看到新生成的github页面\n\n### 搭建本地博客编写环境\n\n#### 参照ink的帮助文档部分直接从源码构建\n\n- 安装go环境`brew install go`，设置GOPATH为`export GOPATH=\"~/Github/go\"`\n- 为了方面以后修改，从ink的github页面直接fork一份\n- 运行`go get github.com/tizzzybec/ink`获取ink极其依赖并编译，编译后的ink可执行文件位于$GOPATH/bin下\n- 添加`expoert=$PATH:$GOPATH/bin`到~/.zshrc文件，以便能随时调用ink命令\n- 运行`ink preview $GOPATH/src/github.com/tizzybec/ink/template`后，按控制台提示打开浏览器即可预览\n- 切换到工作目录为`$GOPATH/src/github.com/tizzybec/ink/template`，在source目录下编写markdown文件，运行`ink build`生成博客内容，在浏览器预览中能看到实时的排版效果\n\n更新windows下操作\n\n- `git clone github.com/tizzzybec/ink`\n- `go build`\n- `.\\ink.exe preview templates`\n- `.\\ink.exe build templates`\n\n#### 编辑`config.yml`，参照注释进行常用信息的修改\n\n``` yaml\n\nsite:\n    title: 生活∙编码-日记\n    subtitle: keep it simple and stupid.\n    logo: /images/tizzybec.jpg\n    limit: 10\n    theme: theme\n    disqus: tizzybec\n    lang: zh\n    url: http://www.tizzybec.com/\n    # root: /blog\n\nauthors:\n    me:\n        name: tizzybec\n        intro: c++码农，haskell/clojure学习中...\n        avatar: /images/tizzybec.jpg\n\nbuild:\n    port: 8000\n    # Copied files to public folder when build\n    copy:\n        - theme/css\n        - theme/js\n        - theme/favicon.ico\n        - theme/robots.txt\n        - source/images\n    # Excuted command when use 'ink publish'\n    publish: |\n        export from_path=~/Github/go/src/github.com/tizzybec/ink/template/public/\n        export to_path=~/Github/tizzybec.github.io/\n        cp -RP $from_path $to_path\n        cd $to_path\n        git add . -A\n        git commit -m \"update\"\n        git push origin\n\n```\n\n#### 添加cc协议标识\n\n修改_footer.html文件\n``` html\n\u003cspan class=\"license\"\u003e\n      \u003ca rel=\"license\" href=\"//creativecommons.org/licenses/by/4.0/\" title=\"Creative Commons Attribution 4.0 International license\"\u003e\n        \u003cimg src=\"{{.Site.Root}}/images/cc88x31.png\" alt=\"License\" data-pin-nopin=\"true\" /\u003e\n      \u003c/a\u003e\n\u003c/span\u003e\n```\n修改index.less文件\n\n``` css\n.license {\n      float: right;\n      padding: 0;\n}\n```\n\n### 绑定自定义域名\n\n去 *万网/dnspod/花生壳* 都可以申请到域名，付费后到控制台新建一条域名解析记录\n\n```\n子域名 记录类型   记录值                TTL\nwww   CNAME     tizzybec.github.io  600\n```\n\n在`tizzybec.github.io`仓库根目录执行`echo \"www.tizzybec.com\" \u003e CNAME`，提交到github\n\n现在访问[tizzybec](http://www.tizzybec.com/)就是最终的个人博客站点了。\n\n## 其它\n\n- 修改了coffee/less文件需要使用gulp重新构建前端文（`cd theme \u0026\u0026 gulp \u0026\u0026 cd .. \u0026\u0026 ink build`）\n- 暂时不支持单个md的构建命令，后续如果支持比较好\n\n","cover":"/images/ink.png","link":"build-blog-with-ink.html","preview":"\u003cp\u003eink是一款简洁的静态博客构建工具，结合github pages能够快速搭建个人博客\u003c/p\u003e\n","title":"使用InkPaper搭建个人博客"}]