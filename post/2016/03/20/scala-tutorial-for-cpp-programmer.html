<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=1, minimum-scale=1, maximum-scale=1">
        <meta name="keywords" content="C&#43;&#43;,Scala,">
        <meta name="description" content="面向c&#43;&#43;程序员的scala教程">
        <link rel="stylesheet" href="/css/index.css">
        <link rel="stylesheet" href="/css/github.css">
        <title>面向c&#43;&#43;程序员的scala教程</title>
        <script>
          var _hmt = _hmt || [];
          (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?a873b1a598faa7a2c5f0b208b5a78578";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
          })();
        </script>
    </head>
    <body>
        <article class="container">
            <a class="index" href="/">tizzybec@weibo</a>
<ul class="menu">
    <li class="menu-item"><a href="/archive.html">归档</a></li>
    <li class="menu-item"><a href="/tag.html">标签</a></li>
    
    <li class="menu-item"><a href="/about.me.html">关于</a></li>
</ul>

            <article class="main article">
                <h1 class="title">面向c&#43;&#43;程序员的scala教程</h1>
                <section class="info">
                    <span class="avatar" style="background-image: url(/images/tizzybec.jpg);"></span>
                    <a class="name" href="/about.me.html">tizzybec</a>
                    <span class="date" data-time="1458485340">
                        <span class="from"></span>
                        <span class="date" data-time="1458485340">(<span class="from"></span> 更新)</span>
                    </span>
                    <span class="tags"><a class="tag" href="/tag/C&#43;&#43;/index.html">C&#43;&#43;</a><a class="tag" href="/tag/Scala/index.html">Scala</a></span>
                </section>
                <article class="content"><p>最近在研究finagle，打算先从scala语言开始学习。本文不能作为scala的入门教程，内容也不尽完善和准确，只是作为个人学习笔记之用。</p>

<h2>scala观点</h2>

<ul>
<li><a href="https://www.zhihu.com/question/28573046">Scala语言设计有哪些缺陷?</a></li>
<li><a href="https://www.zhihu.com/question/27332932">为什么说 Scala 是 JVM 上的 C++？</a></li>
<li><a href="https://www.zhihu.com/question/38032439">为啥 Erlang 没有像 Go、Scala 语言那样崛起？</a></li>
<li><a href="https://www.zhihu.com/question/19748408">Scala 是一门怎样的语言，具有哪些优缺点？</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-funinscala3/index.html">有趣的 Scala 语言: 函数成了一等公民</a></li>
</ul>

<p>一个有趣的观点
 <img src="/images/loader.gif" data-src="/images/scala-view-point.png" alt="图片来自zhihu.com，侵删" /></p>

<h2>Scala学习资源</h2>

<ul>
<li><a href="http://product.dangdang.com/1349099431.html">Scala与Clojure函数式编程模式：Java虚拟机高效编程</a></li>
<li><a href="http://product.dangdang.com/23630366.html">深入理解Scala</a></li>
<li><a href="http://twitter.github.io/scala_school/zh_cn/index.html">Scala课堂</a></li>
<li><a href="http://docs.scala-lang.org/">Scala语言官方站点</a></li>
<li><a href="http://twitter.github.io/effectivescala/index-cn.html">Effective Scala</a></li>
<li><a href="http://docs.scala-lang.org/style/">官方编码规范</a></li>
<li><a href="http://www.scala-lang.org/api/current/#package">Scala api reference</a></li>
</ul>

<h2>构建基本的scala环境</h2>

<h3>windows</h3>

<p>由于的代理服务器不是很稳定，所以使用typesafe的<a href="http://www.lightbend.com/activator/download">activator</a>作为开发构建工具，兼容sbt的所有命令</p>

<h3>Mac</h3>

<p>typesafe会搜寻如下文件夹进行执行</p>

<ul>
<li>Sources in the base directory</li>
<li>Sources in src/main/scala or src/main/java</li>
<li>Tests in src/test/scala or src/test/java</li>
<li>Data files in src/main/resources or src/test/resources</li>
<li>jars in lib</li>
</ul>

<h3>IDE</h3>

<p>推荐IntelliJ Idea，支持sbt构建工具
<a href="https://www.jetbrains.com/idea/download/">下载地址</a></p>

<h3>activator环境测试</h3>

<p>输入<code>activator shell</code>进入shell模式，<code>console</code>进入scala的repl。</p>

<p>建立src\main\scala\helloworld.scala文件，编写测试代码</p>

<pre><code class="language-scala">object Hi {
  def main(args: Array[String]) = println(&quot;Hello world!&quot;)
}
</code></pre>

<p>在shell模式下执行<code>run</code>，输出&rdquo;Hello world!&ldquo;，基本scala编译环境准备完成，这里不对sbt作过多的学习。</p>

<h2>基础部分</h2>

<h3>内置类型</h3>

<p><img src="/images/loader.gif" data-src="/images/scala-type-hierarchy.jpg" alt="scala type hierarchy" /></p>

<h3>定义可变变量</h3>

<pre><code class="language-scala">var variableType : String = &quot;123&quot;
</code></pre>

<h3>定义不可变变量</h3>

<pre><code class="language-scala">val constVariableType : Int = 123
</code></pre>

<h3>函数</h3>

<p>不带参数时括号可以省略，返回类型可以被推导时可以省略返回值类型。</p>

<pre><code class="language-scala">def noneParamFunction = &quot;123&quot;
def noneParamWithReturnType : String= &quot;123&quot;
def onePramWithReturnType(i : Int) = i + 1
def functionDefinationSpanTwoLine(i : Int) = {
   val a = i + 1
   a + 1
}
</code></pre>

<p>返回值为空的函数</p>

<pre><code class="language-scala">def nullReturnValueFun={} //f:Uint`
</code></pre>

<p>使用<code>=&gt;</code>创建匿名函数，匿名不需要制定返回值。</p>

<pre><code class="language-scala">(i : Int) =&gt; i + 1
</code></pre>

<h3>注释</h3>

<p>和C++一样，支持//和/<em>&hellip;</em>/</p>

<h3>流程控制</h3>

<p>直接把语法定义搬过来</p>

<pre><code>`if' `(' Expr `)' {nl} Expr [[semi] `else' Expr]
`while' `(' Expr `)' {nl} Expr
`try' (`{' Block `}' | Expr) [`catch' `{' CaseClauses `}'] [`finally' Expr]
`do' Expr [semi] `while' `(' Expr ')'
`for' (`(' Enumerators `)' | `{' Enumerators `}') {nl} [`yield'] Expr
`throw' Expr
`return' [Expr]
</code></pre>

<h3>关键字</h3>

<blockquote>
<p>abstract case catch class def<br />
do else extends false final<br />
finally for forSome if implicit<br />
import lazy macro match new<br />
null object override package private<br />
protected return sealed super this<br />
throw trait try true type<br />
val var while with yield<br />
_ : = =&gt; &lt;- &lt;: &lt;% &gt;: # @</p>
</blockquote>

<p><strong><em>注意：</em></strong>在scala中访问java标识符含有scala关键字式用``进行转义。</p>

<h3>表达式</h3>

<blockquote>
<p>Scala中（几乎）一切都是表达式</p>
</blockquote>

<h3>包Package</h3>

<h4>声明包</h4>

<pre><code class="language-scala">package myFirstPackage
</code></pre>

<h4>支持嵌套</h4>

<pre><code class="language-scala">package com {
    package tizzybec {
        package toy {
            ...
        }    
    }
}
</code></pre>

<h4>引用包</h4>

<p>引用制定成员</p>

<pre><code class="language-scala">import java.awt.Color
</code></pre>

<p>引用所有成员</p>

<pre><code class="language-scala">import java.awt._
</code></pre>

<p>引用部分成员</p>

<pre><code class="language-scala">import java.awt.{Color, Font}
</code></pre>

<p>给成员别名</p>

<pre><code class="language-scala">import java.util.{HashMap =&gt; JavaHashMap}
</code></pre>

<p>使用别名和部分成员可以达到吟唱部分包的目的</p>

<pre><code class="language-scala">import java.util.{HashMap =&gt; _, _} 
</code></pre>

<p>对于当前包宇引入包内成员名字重名的情况使用<code>_root_</code>指向包的根部来引用当前包内的制定成员</p>

<h3>对象Class</h3>

<p>class定义与java相似</p>

<pre><code class="language-scala">class myFirstScalaClass {}
</code></pre>

<p>单例模式支持</p>

<pre><code class="language-scala">object SingletonClass
</code></pre>

<p>私有变量，同名的class和object互为友元</p>

<pre><code class="language-scala">class ObjectHasPrivateMember {
    import ObjectHasPrivateMember ._

    def privateMember = realPrivateMember
}

object ObjectHasPrivateMember {
    private def readPrivateMember = 12
}
</code></pre>

<h3>异常支持</h3>

<p>异常支持应该是为了兼容java库的使用，除非使用java带异常函数，个人很少使用异常</p>

<pre><code class="language-scala">val result: Int = try {
        remoteCalculatorService.add(1, 2)
    } catch { 
         case e: ServerIsDownException =&gt; { log.error(e, &quot;the remote calculator service is unavailable. should have kept your trusty HP.&quot;) 0 }
    } finally { 
        remoteCalculatorService.close()
    }
</code></pre>

<p>scala的异常是表达式级别的，支持finally，支持模式匹配</p>

<h3>与java的互操作性</h3>

<p>如果对scala生成的代码有疑问，使用JDK自带的javap反编译工具进行查看，由于我对java字节码不是很熟悉，这里就不深入了</p>

<p>具体操作规则略。</p>

<h2>特性trait</h2>

<p>特性和java/C++中的虚函数属于同等概念，trait定义的接口可实现也可以不实现</p>

<p>trait可以从class继承，通过with进行mixin（混入），从scala-lang引入一个例子</p>

<pre><code class="language-scala">abstract class AbsIterator{
    type T
    def hasNext:Boolean
    defnext: T
 }

trait RichIterator extends AbsIterator {
    defforeach(f: T =&gt; Unit) { while(hasNext) f(next) }
}

class StringIterator(s: String) extends AbsIterator {
    type T = Char
    private var i =0
    def hasNext = i &lt; s.length()
    def next = { val ch = s charAt i; i +=1; ch }
}

object StringIteratorTest {
    def main(args:Array[String]){
        class Iter extendsStringIterator(args(0)) with RichIterator
        val iter = newIter
        iter foreach println
    }
}
</code></pre>

<p>通过使用<code>with RichIterator</code>，Iter 混入了RichIterator的行为，也就是mixin-class composition，对于不支持多重继承的语言，mixin能够很好突破这个限制，对mixin理解为内联还是ducktype的语法糖呢？</p>

<p>延伸阅读：<a href="https://www.zhihu.com/question/20778853">Mixin是什么概念</a></p>

<h2>集合collection</h2>

<p>scala对集合的支持非常完善，很适合进行大数据的处理。集合主要分为四类</p>

<ul>
<li>链表List</li>
<li>集Set</li>
<li>序列Seq</li>
<li>映射map</li>
</ul>

<p>这几类是基类，在scala中有更多的用途的集合。</p>

<p>所有集合都拥有以下特质</p>

<ul>
<li>可遍历性，Traversable特质，定义了map、foreach、find、filter、partition和groupBy等函数</li>
<li>可迭代性，Iterable特质，定义了hasNext和next等函数</li>
</ul>

<p>集合严格区分mutable和immutable，不可变特性是函数式编程中经常使用，可变状态会带来线程安全问题</p>

<h2>注解</h2>

<p>scala在注解的使用上基本和java保持一致，这个特性是在JDK1.5以后引入的，注解相当于代码的元数据，scala常用的注解包括：</p>

<ul>
<li>cloneable</li>
<li>inline</li>
<li>native</li>
<li>remote</li>
<li>serializable</li>
<li>throws</li>
<li>transient</li>
<li>uncheked</li>
<li>volatile</li>
</ul>

<p>这篇文章<a href="http://roadtopro.me/scala/annotation/">Scala基础之注解(annotation)</a>讲了常用注解的使用</p>

<p>用上注解就有点c++的味道了，比起c++，在写法上更具一致性，像Deprecated，c++里只能只能以来各个编译器的隐含特性，tailrec支持尾递归优化就实在是太赞了，还有像transient对属性进行注解能更加精准地控制序列化的过程，c++里面撸reflection和serialization可就全靠hack手段了（全是宏和模板）</p>

<h2>函数式编程</h2>

<h3>柯里化</h3>

<p>scala对currying的支持非常好，直接定义参数链就可以：</p>

<pre><code class="language-scala">def curryingFunc(i: Int)(j :  String)
</code></pre>

<h3>函数组合</h3>

<p>组合函数直接内置compose关键字进行支持</p>

<pre><code class="language-scala">def f(s String): String = &quot;f(&quot; + s + &quot;)&quot;
def g(s: String): String= &quot;g(&quot; + s + &quot;)&quot;
def fComposeG = f _ compose g _
fComposeG (&quot;x&quot;)  //return f(g(x))
</code></pre>

<p>scala提供一个和compose相反调用顺序的函数andThen ，改写上面的例子</p>

<pre><code class="language-scala">def f(s String): String = &quot;f(&quot; + s + &quot;)&quot;
def g(s: String): String= &quot;g(&quot; + s + &quot;)&quot;
def fAndThenG = f _ andThen g _
fAndThenG (&quot;x&quot;)  //return g(f(x))
</code></pre>

<h3>偏函数（partial function）</h3>

<p>先看看函数和偏函数的差异：</p>

<blockquote>
<p>对给定的输入参数类型，函数可接受该类型的任何值.
对给定的输入参数类型，偏函数只能接受该类型的某些特定的值</p>
</blockquote>

<p>偏函数支持调用isDefinedAt方法查询是够支持给定参数，偏函数的一个特例就是case语句，case本身就是偏函数的一个子类</p>

<p>使用orElse可以对偏函数进行组合，语句从第一个偏函数开始匹配直到匹配输入，或者到达最后一个orElse</p>

<pre><code class="language-scala">val partial = one orElse two orElse three orElse wildchar
</code></pre>

<p>上述语句先检查one是够接受参数，然后是two，然后是three，如果均没有匹配则匹配最后的通配符wildchar</p>

<p>偏函数是函数的子类型，任何接受函数参数的地方均接受偏函数</p>

<h2>泛型</h2>

<h3>类型推导</h3>

<p>Scala有秩1多态性(未查到)，下面的代码无法编译通过</p>

<pre><code class="language-scala">def foo[A](f: A =&gt; List[A], i: Int) = f(i)
</code></pre>

<p>如果拿C++改写，可能是这样的（徒手码的）</p>

<pre><code class="language-scala">template &lt;typename A&gt;
A foo(std::list&lt;A&gt; (const *f)(A), const A &amp;i) {
    return f(i);
}
</code></pre>

<p>C++编译器能够正常推导所有类型</p>

<p>在scala school中有这么一句话：</p>

<blockquote>
<p>在Scala中所有类型推断是局部的。Scala一次分析一个表达式。</p>
</blockquote>

<p>我们可以理解为scala编译器分别对<code>f: A =&gt; List[A]</code>和<code>i: Int</code>进行了推导，但是没有对f(i)进行联合推导，这点从C++过来的多多少少有些不适应。</p>

<h2>模式匹配</h2>

<p>使用函数式语言，模式匹配的支持确实给代码的编写带来很多便利，scala通过match关键字进行模式匹配，看一个例子</p>

<pre><code class="language-scala">val times = 1
times match {
  case 1 =&gt; &quot;one&quot;
  case 2 =&gt; &quot;two&quot;
  case _ =&gt; &quot;some other number&quot;
}
</code></pre>

<h3>类型匹配支持</h3>

<pre><code class="language-scala">def bigger(o: Any): Any = {
  o match {
    case i: Int if i &lt; 0 =&gt; i - 1
    case i: Int =&gt; i + 1
    case d: Double if d &lt; 0.0 =&gt; d - 0.1
    case d: Double =&gt; d + 0.1
    case text: String =&gt; text + &quot;s&quot;
  }
}
类成员匹配，和if语句差不过
``` scala
def calcType(calc: Calculator) = calc match {
  case _ if calc.brand == &quot;hp&quot; &amp;&amp; calc.model == &quot;20B&quot; =&gt; &quot;financial&quot;
  case _ if calc.brand == &quot;hp&quot; &amp;&amp; calc.model == &quot;48G&quot; =&gt; &quot;scientific&quot;
  case _ if calc.brand == &quot;hp&quot; &amp;&amp; calc.model == &quot;30B&quot; =&gt; &quot;business&quot;
  case _ =&gt; &quot;unknown&quot;
}
</code></pre>

<h3>样本类（Case classes）匹配</h3>

<pre><code class="language-scala">case class Calculator(brand: String, model: String)
val hp20b = Calculator(&quot;hp&quot;, &quot;20B&quot;)
val hp30b = Calculator(&quot;hp&quot;, &quot;30B&quot;)
def calcType(calc: Calculator) = calc match {
    case Calculator(&quot;hp&quot;, &quot;20B&quot;) =&gt; &quot;financial&quot;
    case Calculator(&quot;hp&quot;, &quot;48G&quot;) =&gt; &quot;scientific&quot;
    case Calculator(&quot;hp&quot;, &quot;30B&quot;) =&gt; &quot;business&quot;
    case Calculator(ourBrand, ourModel) =&gt; &quot;Calculator: %s %s is of unknown type&quot;.format(ourBrand, ourModel)
}
</code></pre>

<h2>协变，逆变</h2>

<p>关于逆变和协变，可以参考以下博客进行学习
<a href="http://www.cnblogs.com/en-heng/p/5041124.html">Java中的逆变与协变</a></p>

<p>这里摘出几个要点</p>

<h3>定义</h3>

<blockquote>
<p>逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果A、B表示类型，f(⋅)表示类型转换，≤表示继承&gt;关系（比如，A≤B表示A是由B派生出来的子类）；<br />
f(⋅)是逆变（contravariant）的，当A≤B时有f(B)≤f(A)成立；<br />
f(⋅)是协变（covariant）的，当A≤B时有f(A)≤f(B)成立；<br />
f(⋅)是不变（invariant）的，当A≤B时上述两个式子均不成立，即f(A)与f(B)相互之间没有继承关系。</p>
</blockquote>

<h3>理解</h3>

<blockquote>
<p>extends确定了泛型的上界，而super确定了泛型的下界</p>
</blockquote>

<h3>区分</h3>

<blockquote>
<p>PECS原则：producer-extends, consumer-super.</p>
</blockquote>

<h3>示例</h3>

<pre><code class="language-java">public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)
...
</code></pre>

<p>理解和协变确定了泛型的上界，逆变确定了类型的下界，逆变和协变基本就理解清楚了</p>

<p>回到scala的协变和逆变，举一个scala内置单参数函数的trait定义</p>

<pre><code class="language-scala">trait Function1 [-T1, +R] extends AnyRef
</code></pre>

<p>可以理解为函数参数传入是逆变的，函数返回值是协变的</p>

<p>在支持协变和逆变语法的基础上，scala支持类型边界，在泛型编程中通过指定类型的边界，结合逆变协变的语法可以作类型约束</p>

<h3>通配符_</h3>

<p>_可以在模板中匹配类型</p>

<pre><code class="language-scala">def count(l: List[_]) = l.size //ignore list element type
</code></pre>

<p>也可以在Partial application模拟std::bind的语法，从旧的函数中通过部分参数绑定得到新的函数</p>

<pre><code class="language-scala">def adder(m: Int, n: Int) = m + n
val add2 = adder(2, _:Int)
</code></pre>

<p>这和在javascript中经常会使用闭包特性返回部分应用后的新函数是类似的东西</p>

<h2>对monad的理解</h2>

<p>参考：<a href="http://hongjiang.info/semigroup-and-monoid/">http://hongjiang.info/semigroup-and-monoid/</a></p>

<ol>
<li>封闭性（Closure）：对于任意a，b∈G，有a*b∈G</li>
<li>结合律（Associativity）：对于任意a，b，c∈G，有（a*b）*c=a*（b*c）</li>
<li>幺元 （Identity）：存在幺元e，使得对于任意a∈G，e*a=a*e=a</li>
<li>逆元：对于任意a∈G，存在逆元a^-1，使得a^-1*a=a*a^-1=e</li>
</ol>

<p><strong>半群（semigroup）：</strong>满足封闭性和结合律</p>

<p><strong>幺半群（monoid）：</strong> 是半群且有幺元。</p>

<p><strong>函数(morphism)：</strong>类型之间的映射。</p>

<p><strong>范畴：</strong>一组类型的集合，为了理解可简单理解为高阶类型。</p>

<p><strong>函子（functor）：</strong>
一个范畴内的元素可以映射为另一个范畴的元素，且元素之间的关系也可以映射为另一个范畴的关系。对于范畴C1和C2有</p>

<ol>
<li>将C1中的类型 T 映射为 C2 中的 List[T] :  T =&gt; List[T]</li>
<li>将C1中的函数 f 映射为 C2 中的 函数fm :  (A =&gt; B) =&gt; (List[A] =&gt; List[B])</li>
</ol>

<p>通常带有map方法的类型构造器就是一个函子。</p>

<p><strong>自函子（endfunctor）：</strong>将范畴映射到自身的单子。</p>

<p><strong>单子（monad）：</strong>自函子范畴上的一个幺半群。</p>

<h2>和C++对比</h2>

<h3>优点:</h3>

<ol>
<li>对函数式编程的支持</li>
<li>模式匹配（包括类匹配）能够写出更加简洁的代码</li>
<li>支持高阶函数，C++通过bind和function来模拟其实也问题不大</li>
<li>比C++更加强大的类型推导系统</li>
<li>支持Mixin，通过traits</li>
<li>对类型反射的支持</li>
<li>包比namespace好用，模块化管理</li>
<li>支持注解，目前来说注解还是个好东西</li>
<li>具名参数，C++没有真是遗憾</li>
<li>对于集合的非常强大</li>
<li>对可变参数简单</li>
<li>可以复用jvm上的很多软件包</li>
<li>大数据软件多数是基于scala写的</li>
</ol>

<h3>缺点：</h3>

<ol>
<li>过于复杂的语法和操作符</li>
<li>过多的隐式类型转换，隐式转换用起来会很爽</li>
<li>不同版本的jar二进制不兼容</li>
<li>写完全暴露给java调用的代码比较困难，强制scala技术栈</li>
<li>太灵活了，有时候也是缺点</li>
</ol>
</article>
                <section class="author">
                    <div class="avatar" style="background-image: url(/images/tizzybec.jpg);"></div>
                    <a class="name" href="/about.me.html">tizzybec</a>
                    <div class="intro">c&#43;&#43;程序员，haskell/luajit学习中...</div>
                </section>
                <section class="recommend">
                    
                    
                    <section class="nav next">
                        <div class="head">下篇文章</div>
                        <a class="link" href="/post/2015/10/04/cpp-dynamic-initializer.html">C&#43;&#43;动态初始化（Dynamic Initializer）</a>
                    </section>
                    
                </section>
                <section id="disqus_thread"></section>
            </article>
        </article>
        <footer class="footer">
    <span class="copyright">
        tizzybec@weibo ©
        <script type="text/javascript">
            document.write(new Date().getFullYear());
        </script>
    </span>
    <span class="license">
      <a rel="license" href="//creativecommons.org/licenses/by/4.0/" title="Creative Commons Attribution 4.0 International license">
        <img src="/images/cc88x31.png" alt="License" data-pin-nopin="true" />
      </a>
    </span>
    <span class="publish">Powered by <a href="http://www.inkpaper.io/" target="_blank">Ink</a></span>
</footer>
        <script src="/js/jquery-1.11.2.min.js"></script>
        <script src="/js/highlight.pack.js"></script>
        <script src="/js/jquery.unveil.js"></script>
        <script src="/js/index.js"></script>
        <script type="text/javascript">
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//tizzybec.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
    </body>
</html>
